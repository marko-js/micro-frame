import path from "path";
import https from "https";
import fetch from "make-fetch-happen";
import consumeResponseBody from "../../../util/consume-body";
static const { ca } = https.globalAgent.options;
static const cachePath = path.resolve("node_modules/.cache/fetch");
static const strictSSL = process.env.NODE_TLS_REJECT_UNAUTHORIZED !== "0";
static function internalFetch(url, options) {
  return fetch(url, { ...options, ca, cachePath, strictSSL });
}
static async function fetchBody(input, out, buffer) {
  const global = out.global;
  let origin;
  let incomingHeaders;

  if (global.platform) {
    const url = global.url;
    if (!url) {
      throw new Error(
        "Please assign $global.platform.url with WHATWG URL object compatible with @marko/run.",
      );
    }

    const request = global.request;
    if (!request || !request.headers) {
      throw new Error(
        "Please assign $global.platform.request with WHATWG request object compatible with @marko/run.",
      );
    }

    incomingHeaders = Object.fromEntries(request.headers);
    const forwardedProto = request.headers.get("x-forwarded-proto");
    const forwardedHost = request.headers.get("x-forwarded-host");
    origin =
      forwardedHost && forwardedProto
        ? `${forwardedProto}://${forwardedHost}`
        : url.origin;
  } else {
    const incomingMessage =
      (out.stream && (out.stream.req || out.stream.request)) ||
      out.global.req ||
      out.global.request;
    if (!incomingMessage) {
      throw new Error(
        "Could not get request from stream/global. Please assign out.global.req with proper request object.",
      );
    }

    incomingHeaders = incomingMessage.headers;
    const protocol =
      incomingHeaders["x-forwarded-proto"] || incomingMessage.protocol;
    const host = incomingHeaders["x-forwarded-host"] || incomingHeaders.host;
    origin = `${protocol}://${host}`;
  }

  const url = new URL(input.src, origin);
  const { cache } = input;
  const headers = {
    ...incomingHeaders,
    ...input.headers,
    accept: "text/html",
  };

  const res = await (input.fetch
    ? input.fetch(
        url,
        {
          cache,
          headers,
        },
        internalFetch,
      )
    : fetch(url, {
        cache,
        headers,
        ca,
        cachePath,
        strictSSL,
      }));

  if (!res.ok) throw new Error(res.statusText);

  if (buffer) return res.text();

  return consumeResponseBody(res);
}

<div id=component.id class=input.class style=input.style data-src=input.src>
  <if(input.loading && !input.clientReorder)>
    <!--
    We put the streamed html in a preserved fragment.
    This allows Marko to avoid diffing that section.
    -->
    $ out.bf("@b", component, true);
    <${input.loading}/>
    <!-- output a comment used as a marker to detect where the loading content starts so it can be removed -->$!{`<!--${component.id}-->`}
    $ out.ef();
  </if>

  <!--
  We put the streamed html in a preserved fragment.
  This allows Marko to avoid diffing that section.
  -->
  $ out.bf("@_", component, true);
  <if(input.clientReorder)>
    <await(fetchBody(input, out, true))
      client-reorder
      placeholder=input.loading
      timeout=input.timeout
      catch=input.catch
    >
      <@then|html|>
        $!{html}
      </@then>
    </await>
  </if>
  <else>
    <await(fetchBody(input, out, false))
      timeout=input.timeout
      catch=input.catch
    >
      <@then|iter|>
        <ssr-wait
          id=component.id
          iter=iter
          timeout=input.timeout
          loading=input.loading
          catch=input.catch
        />
      </@then>
    </await>
  </else>
  $ out.ef();
</div>

import path from "path";
import fetch from "make-fetch-happen";

static const cachePath = path.resolve("node_modules/.cache/fetch");
static const strictSSL = process.env.NODE_TLS_REJECT_UNAUTHORIZED !== "0";

static async function fetchStream(input, out) {
  const global = out.global;
  let origin;
  let incomingHeaders;

  if (global.platform) {
    const request = global.request;
    if (!request || !request.headers) {
      throw new Error("Please assign $global.platform.request with WHATWG request object compatible with @marko/run.");
    }

    incomingHeaders = Object.fromEntries(request.headers);
    origin = request.url;
  } else {
    const incomingMessage = out.stream && (out.stream.req || out.stream.request) || out.global.req || out.global.request;
    if (!incomingMessage) {
      throw new Error("Could not get request from stream/global. Please assign out.global.req with proper request object.");
    }

    incomingHeaders = incomingMessage.headers;
    origin = `${incomingMessage.protocol}://${incomingHeaders.host}`;
  }


  const url = new URL(input.src, origin);
  const { cache } = input;
  const headers = {
    ...incomingHeaders,
    ...input.headers,
    accept: "text/html",
  };

  const res = await (input.fetch
    ? input.fetch(url, { cache, headers }, fetch)
    : fetch(url, {
      cache,
      headers,
      cachePath,
      strictSSL,
    })
  );

  if (!res.ok) throw new Error(res.statusText);

  if (!res.body || !res.body[Symbol.asyncIterator]) {
    throw new Error("Response body must be a stream.");
  }

  return res.body[Symbol.asyncIterator]();
}

<div id=component.id class=input.class style=input.style data-src=input.src>
  <if(input.loading)>
    <${input.loading}/>
    <!-- output a comment used as a marker to detect where the loading content starts so it can be removed -->
    $!{`<!--${component.id}-->`}
  </if>

  <!--
  We put the streamed html in a preserved fragment.
  This allows Marko to avoid diffing that section.
  -->
  $ out.bf("@_", component, true);
  <await(fetchStream(input, out)) timeout=input.timeout catch=input.catch>
    <@then|iter|>
      <macro name="wait">
        <await(iter.next()) timeout=input.timeout>
          <@then|{ value, done }|>
            <if(done)>
              <if(input.loading)>
                <!-- Remove all of the <@loading> content after we've received all the data -->
                $ out.script(`((e,t,d)=>{t=document.getElementById(e);do{t.removeChild(d=t.firstChild)}while(d.data!==e)})(${JSON.stringify(component.id)});`);
              </if>
            </if>
            <else>
              $!{value}
              <wait/>
            </else>
          </@then>
          <@catch|err|>
            <if(input.catch)>
              <!-- Remove everything in the container and render our catch handler -->
              <script>document.getElementById(${JSON.stringify(component.id)}).textContent=""</script>
              <${input.catch}(err)/>
            </if>
            <else>
              $ throw err;
            </else>
          </@catch>
        </await>
      </macro>

      <wait/>
    </@then>
  </await>
  $ out.ef();
</div>

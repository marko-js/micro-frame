import fetch from "make-fetch-happen";
import path from "path";
import { getOrCreateStreamSource } from "./helper";

static const cachePath = path.resolve("node_modules/.cache/fetch");

$ const request = async () => {
  const global = out.global;
  let origin;
  let incomingHeaders;

  if (global.platform) {
    const url = global.url;
    if (!url) {
      throw new Error("Please assign $global.platform.url with WHATWG URL object compatible with @marko/run.");
    }

    const request = global.request;
    if (!request || !request.headers) {
      throw new Error("Please assign $global.platform.request with WHATWG request object compatible with @marko/run.");
    }


    incomingHeaders = Object.fromEntries(request.headers);
    origin = url.origin;
  } else {
    const incomingMessage = out.stream && (out.stream.req || out.stream.request) || out.global.req || out.global.request;
    if (!incomingMessage) {
      throw new Error("Could not get request from stream/global. Please assign out.global.req with proper request object.");
    }

    incomingHeaders = incomingMessage.headers;
    origin = `${incomingMessage.protocol}://${incomingHeaders.host}`;
  }

  const url = new URL(input.src, origin);
  const res = await (input.fetch || fetch)(url, {
    cachePath,
    cache: input.cache,
    strictSSL: process.env.NODE_TLS_REJECT_UNAUTHORIZED !== "0",
    headers: {
      ...incomingHeaders,
      ...input.headers
    }
  })

  if (!res.ok) throw new Error(res.statusText);

  return res;
}

$ const streamSource = getOrCreateStreamSource(input.name, out);

<div id=component.id data-src=input.src>
  $ out.bf("@_", component, true);
  <await(request()) client-reorder timeout=input.timeout>
    <@then|{ body }|>
      <await(streamSource.run(input.parser(body[Symbol.asyncIterator]()))) client-reorder>
        <@catch|err|>
          $ streamSource.close(err);
        </@catch>
      </await>
    </@then>
    <@catch|err|>
      $ streamSource.close(err);
    </@catch>
  </await>
  $ out.ef();
</div>

